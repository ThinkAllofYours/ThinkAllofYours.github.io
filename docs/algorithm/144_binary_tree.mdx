---
slug: 144_binary_tree
title: ğŸš€ 144.Â Binary Tree Preorder Traversal
authors: [bundabergman]
tags: [algorithm, binary-tree, preorder-traversal]
---

- **144.Â Binary Tree Preorder Traversal**
    
    [Binary Tree Preorder Traversal - LeetCode](https://leetcode.com/problems/binary-tree-preorder-traversal/)
    
    ì´ëŸ° ë¬¸ì œëŠ” forë¬¸ìœ¼ë¡œ í•´ê²°í•˜ëŠ” ê²ƒë³´ë‹¤ recursiveë¡œ í•´ê²°í•˜ëŠ” ê²ƒì´ ë°”ëŒì§í•˜ë‹¤ê³  ìƒê°í–ˆë‹¤.
    
    binary treeê°€ ë°ì´í„° êµ¬ì¡°ë¡œ ìˆìœ¼ë©´ forë¬¸ìœ¼ë¡œ í•´ê²°í•˜ëŠ”ê±´ ì–´ë µë‹¤
    
    ê·¸ë˜ì„œ ìƒê°í•œ ì½”ë“œëŠ”
    
    ```python
    # Definition for a binary tree node.
    # class TreeNode:
    #     def __init__(self, val=0, left=None, right=None):
    #         self.val = val
    #         self.left = left
    #         self.right = right
    class Solution:
        def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
            output = []
            if root and root.val is not None:
                output.append(root.val)
                if root.right or root.left:
                    self.insert_val(output, root.left)
                    self.insert_val(output, root.right)
            return output
    
        def insert_val(self, output, root:Optional[TreeNode]):
            if root is None or root.val is None:
                return
    
            output.append(root.val)
            self.insert_val(output, root.left)
            self.insert_val(output, root.right)
    ```
    
    ì™¼ìª½ë¶€í„° ì˜¤ë¥¸ìª½ ìˆœìœ¼ë¡œ ë°ì´í„°ë¥¼ ë„£ì–´ì•¼ í•œë‹¤.
    
    chat.openAiì—ê²Œ ë¬¼ì–´ë´¤ë”ë‹ˆ
    
    ```python
    # Definition for a binary tree node.
    # class TreeNode:
    #     def __init__(self, val=0, left=None, right=None):
    #         self.val = val
    #         self.left = left
    #         self.right = right
    class Solution:
        def preorderTraversal(self, root: TreeNode) -> List[int]:
            if not root:
                return []
            result = []
            stack = [root]
            while stack:
                node = stack.pop()
                result.append(node.val)
                if node.right:
                    stack.append(node.right)
                if node.left:
                    stack.append(node.left)
            return result
    ```
    
    ì´ë ‡ê²Œ í’€ì—ˆë‹¤. ì‹ ë°•í•œ í’€ì´ë²•ì´ë‹¤. ì•„ë§ˆ ë‹¤ë¥¸ ì‚¬ìš©ìë“¤ì´ í’€ì–´ë†“ì€ ë°©ë²• ì´ê² ì§€?
    
    ì—¬ê¸°ì„œëŠ” ìë£Œêµ¬ì¡°ê°€ stackì´ê¸° ë•Œë¬¸ì— ì˜¤ë¥¸ìª½ë¶€í„° ë¨¼ì €ë„£ì–´ì•¼ ì™¼ìª½ë¶€í„° ë¦¬ìŠ¤íŠ¸ì— ë„£ì„ ìˆ˜ìˆë‹¤.