---
slug: 886_possible_bipartition
title: ðŸš€ 886. Possible Bipartition
authors: [bundabergman]
tags: [algorithm, graph]
---

[Possible Bipartition - LeetCode](https://leetcode.com/problems/possible-bipartition/)

```sql
Input: n = 4, dislikes = [[1,2],[1,3],[2,4]]
Output: true
Explanation: group1 [1,4] and group2 [2,3].
```

ë¬¸ì œë¥¼ ë³´ë©´ ë¦¬ìŠ¤íŠ¸ê°€ ì£¼ì–´ì§€ê³  í•¨ê»˜ ìžˆì„ ìˆ˜ ì—†ëŠ” ìˆ«ìžë“¤ì´ 2ì°¨ì› ë°°ì—´ë¡œ ì£¼ì–´ì§„ë‹¤. 

1ì€ 2ì™€ 3ê³¼ í•¨ê»˜ í•  ìˆ˜ ì—†ê³ 

2ëŠ” 1ê³¼ 4ì™€ í•¨ê»˜ ìžˆì„ ìˆ˜ ì—†ë‹¤

ì£¼ì–´ì§€ëŠ” nê°œì˜ ìˆ˜ë¥¼ ìœ„ì— ì£¼ì–´ì§€ëŠ” ë¦¬ìŠ¤íŠ¸ì— ì°¸ê³ í•´ì„œ ë‘ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ ì•¼ í•œë‹¤. 

ë§Œì•½ì— ë‘ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ ì–´ì§€ë©´ True ë‚˜ëˆ„ì§€ ëª»í•˜ë©´ Falseì´ë‹¤. 

---

â†’ í•´ê²°ë°©ë²•ì„ ì²˜ìŒ ìƒê°í•´ë³´ë©´

ì¼ë‹¨ ê° ìˆ«ìžë“¤ì´ ì–´ë–¤ ìˆ«ìžì™€ í•¨ê»˜ í•  ìˆ˜ ì—†ëŠ”ì§€ë¥¼ ë”•ì…”ë„ˆë¦¬ ìžë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•´ì„œ ì •ë¦¬í–ˆë‹¤.

ì´ì œ ì´ê±¸ ë°°ì¹˜í•´ì•¼ í•˜ëŠ”ë° dictionaryì—ì„œ forë¬¸ì„ ëŒë©´ì„œ ì¤‘ë³µë˜ëŠ”ê²Œ ìžˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ì½”ë“œë¥¼ ìž‘ì„±í–ˆë‹¤. 

```python
from typing import List

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        dislike_dic = {}
        for dislike in dislikes:
            item1 = dislike[0]
            item2 = dislike[1]
            if item1 in dislike_dic:
                dislike_dic[item1].append(item2)
            else:
                dislike_dic[item1] = [item2]

            if item2 in dislike_dic:
                dislike_dic[item2].append(item1)
            else:
                dislike_dic[item2] = [item1]
```

- Code(ìž˜ëª»ëœ ì½”ë“œìž„)
    
    ```python
    				
    				group1 = set()
            group2 = set()
            for i in range(1, n + 1):
                group_name = None
                lst_dislike = []
                if i in dislike_dic:
                    lst_dislike = dislike_dic[i]
                group_name = ''
                for dislike in lst_dislike:
                    if dislike in group1:
                        if dislike in group2:
                            return False
                        if group_name == '':
                            group_name = 'group2'
                        elif group_name != 'group2':
                            # could this element be in group2?
                            if not self.could_be_in_another_group(dislike_dic, dislike, group2, group1):
                                return False
                            group_name = 'group2'
                    elif dislike in group2:
                        if dislike in group1:
                            return False
                        if group_name == '':
                            group_name = 'group1'
                        elif group_name != 'group1':
                            if not self.could_be_in_another_group(dislike_dic, dislike, group1, group2):
                                return False
                            group_name = 'group1'
                if group_name == '' or group_name == 'group1':
                    group1.add(i)
                else:
                    group2.add(i)
            return True
    
        def could_be_in_another_group(self, dislike_dic, dislike, from_group, to_group):
            if dislike in dislike_dic:
                lst_dislike = dislike_dic[dislike]
                for dislike2 in lst_dislike:
                    if dislike2 in from_group:
                        if self.could_be_in_another_group(dislike_dic, dislike2, from_group, to_group):
                            from_group.remove(dislike2)
                            to_group.add(dislike2)
                        else:
                            return False
            return True
    ```
    

ë³´ë©´ ì•Œê² ì§€ë§Œ ë³„ ë‚œë¦¬ë¥¼ ë‹¤ ë¶€ë ¸ë‹¤. 

ì½”ë“œê°€ ë„ˆë¬´ ì§€ì €ë¶„í•´ì„œ ë¦¬íŽ™í† ë§ í•˜ë‹¤ê°€

Chat GPTì—ê²Œ ë¦¬íŒ©í† ë§ì„ ë¶€íƒí•´ ë³´ì•˜ë‹¤. 

- Code(ìž˜ëª»ëœ ì½”ë“œ ë¦¬íŒ©í† ë§)
    
    ```python
    			groups = [set(), set()]
            for i in range(1, n + 1):
                group_name = None
                lst_dislike = dislike_dic.get(i, [])
                group_name = ''
                for dislike in lst_dislike:
                    group_index = None
                    if dislike in groups[0]:
                        group_index = 0
                    elif dislike in groups[1]:
                        group_index = 1
                    if group_index is not None:
                        if group_name == '':
                            group_name = group_index
                        elif group_name != group_index:
                            if not self.could_be_in_another_group(dislike_dic, dislike, groups[group_index], groups[group_index ^ 1]):
                                return False
                            group_name = group_index
                if group_name == '':
                    groups[0].add(i)
                elif group_name == 0:
                    groups[0].add(i)
                else:
                    groups[1].add(i)
            return True
    
        def could_be_in_another_group(self, dislike_dic, dislike, from_group, to_group):
            if dislike in dislike_dic:
                lst_dislike = dislike_dic[dislike]
                for dislike2 in lst_dislike:
                    if dislike2 in from_group:
                        if self.could_be_in_another_group(dislike_dic, dislike2, from_group, to_group):
                            from_group.remove(dislike2)
                            to_group.add(dislike2)
                        else:
                            return False
            return True
    ```
    

***ì˜¤~~~ ìž˜í•œë‹¤ ìž˜í•´***

**ê²°ë¡ ì€ ? í•´ê²°ì•ˆë¨**

ë¬¸ì œëŠ” dictionaryì—ì„œ forë¬¸ì„ ëŒë‹¤ê°€ ìš”ì†Œ í•˜ë‚˜ê°€ 10ì´ë¼ê³  í–ˆì„ë•Œ ì–‘ìª½ ê·¸ë£¹ì— ë‹¤ë“¤ì–´ê°ˆ ìˆ˜ ìžˆëŠ” ê²½ìš°ì—

ì¼ë‹¨ í•˜ë‚˜ì˜ ê·¸ë£¹ì— ë„£ì–´ë‘ë©´ ë’¤ì— 22ì¯¤ ì™”ì„ë•Œ ì¼ë‹¨ í•˜ë‚˜ì˜ ê·¸ë£¹ì— ë„£ì–´ë‘” 10ì´ ë¬¸ì œê°€ ë˜ê³ 

ê·¸ëŸ¼ 10ì„ ë‹¤ì‹œ í™•ì¸í•´ì„œ ë‹¤ë¥¸ ê·¸ë£¹ì— ë„£ì–´ì•¼ í•˜ëŠ”ë° ë„£ëŠ”ë‹¤ê³  ë‹¤ê°€ ì•„ë‹ˆë¼ 1~22ë²ˆê¹Œì§€ ë‹¤ì‹œ í™•ì¸í•´ì•¼ í•˜ëŠ” ë¬¸ì œê°€ ìƒê²¼ë‹¤. 

~~**ëª»í’€ì—ˆë‹¤ GG**~~ ðŸ˜­

aiì—ê²Œ ë¬¼ì–´ë³´ë‹ˆ ë‹µì„ ì•Œë ¤ì£¼ëŠ”ë° íŠ¹ì • ì•Œê³ ë¦¬ì¦˜ì´ ìžˆë‹¨ë‹¤â€¦ 

ì´ëŸ° íŠ¹ì • ì•Œê³ ë¦¬ì¦˜ì„ ê³µë¶€í•´ì•¼ í•˜ëŠ”ê°€???

ê·¸ëŸ¼ ì´ê±´ ì¢€ ì œì™¸í•˜ê³  

---

ë‹¤ì‹œ ì²˜ìŒë¶€í„° ìƒê°í•˜ê¸°ë¡œâ€¦

(ì´ë²ˆ ë¬¸ì œëŠ” ì–´ë µë‹¤ ã… .ã… )

ì¸ìˆ˜ê°€ ì´ë ‡ê²Œ ì£¼ì–´ì¡Œì„ ë•Œ

```python
 Input: n = 4, dislikes = [[1,2],[1,3],[2,4]] 
```

1. ê° ìˆ˜ë³„ë¡œ ì–´ë–¤ìˆ˜ì™€ í•¨ê»˜ í•  ìˆ˜ ì—†ëŠ”ì§€ í™•ì¸
2. ê° ê·¸ë£¹ë³„ë¡œ 1ê³¼ í•¨ê»˜ í•  ìˆ˜ ì—†ëŠ” ìˆ˜ê°€ ìžˆëŠ”ì§€ ë¨¼ì € ê²€ì‚¬
3. í˜„ìž¬ group1 = [ ] group2 = [ ]
4. ë‘˜ë‹¤ ê°€ëŠ¥í•˜ë‹¤ë©´ group1 = [ 1 ]
5. ë‹¤ë¥¸ ê·¸ë£¹ì— 1ê³¼ í•¨ê»˜ í•  ìˆ˜ ì—†ëŠ” ìˆ˜ì¸ 2, 3ì„ ë°˜ë“œì‹œ ë„£ì–´ì•¼í•¨
6. 2ì™€ 3ì´ í•¨ê»˜ í•  ìˆ˜ ìžˆëŠ”ì§€ ê²€ì‚¬
7. 2ì™€ í•¨ê»˜ í•  ìˆ˜ ì—†ëŠ” ë¦¬ìŠ¤íŠ¸ êµ¬í•˜ê¸°
8. 3ê³¼ í•¨ê»˜ í•  ìˆ˜ ì—†ëŠ” ë¦¬ìŠ¤íŠ¸ êµ¬í•˜ê¸°
9. ê° ë¦¬ìŠ¤íŠ¸ë“¤ í•˜ë‚˜ë¡œ í•©ì¹˜ê¸°
10. 2ì™€ 3ì´ í•©ì³ì§„ ë¦¬ìŠ¤íŠ¸ ì•ˆì— ìžˆëŠ”ì§€ í™•ì¸í•˜ê¸°
    1. ê°€ëŠ¥í•˜ë‹¤ë©´ 2ì™€ 3ì€ í•œë²ˆì— group2ì— ë“¤ì–´ê°„ë‹¤. 
11. 2ì™€ 3ì´ í•©ì³ì§„ ë¦¬ìŠ¤íŠ¸ ì•ˆì— ìžˆë‹¤ë©´ return False
12. ëª¨ë“  forë¬¸ì´ ë‹¤ ëŒì•„ê°€ë©´ ìžë™ìœ¼ë¡œ return True

ê²°ê³¼ëŠ” ê¸°ì¡´ë³´ë‹¤ ëª»í•œ ê²°ê³¼ê°€â€¦.ì” ë˜ í‹€ë¦¼

- ì½”ë“œ
    
    ```python
    from typing import List
    
    class Solution:
        def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
            dislike_dic = {}
            for dislike in dislikes:
                item1 = dislike[0]
                item2 = dislike[1]
                if item1 in dislike_dic:
                    dislike_dic[item1].append(item2)
                else:
                    dislike_dic[item1] = [item2]
    
                if item2 in dislike_dic:
                    dislike_dic[item2].append(item1)
                else:
                    dislike_dic[item2] = [item1]
    
            groups = [[], []]
            joined_element = set()
            for key in dislike_dic:
                if key in joined_element:
                    continue
                else:
                    joined_element.add(key)
                lst_dislike = dislike_dic.get(key, [])
                merge_set = set()
                for dislike in lst_dislike:
                    items = dislike_dic.get(dislike, [])
                    for item in items:
                        merge_set.add(item)
                # ìžê¸°ìžì‹ ë¶€í„° ë¨¼ì € ê²€ì‚¬
                # dislikeë“¤ì´ í•¨ê»˜ í•  ìˆ˜ ìžˆëŠ”ì§€ ë¶€í„° ê²€ì‚¬í•¨
                for item in lst_dislike:
                    if item in merge_set:
                        return False
                    joined_element.add(item)
                # ë§Œì•½ í•¨ê»˜ í•  ìˆ˜ ìžˆë‹¤ë©´ ì–´ëŠ ê·¸ë£¹ìœ¼ë¡œ ê°€ì•¼í• ì§€ ê²€ì‚¬
                idx_group = 0
                for item in groups[0]:
                    if item in merge_set:
                        idx_group = 1
                        break
                for item in groups[1]:
                    if item in merge_set and idx_group == 1:
                        return False
                groups[idx_group].append(key)
                # ìƒëŒ€ë°©ìª½ì— ìžˆëŠ” ê²ƒë“¤ì€ ì œì™¸í•œë‹¤.
                for dislike in lst_dislike:
                    if dislike not in groups[idx_group]:
                        groups[idx_group ^ 1].append(dislike)
            return True
    ```
    

---

ëª‡ì¼ì„ ì§¬ì§¬ì´ ìƒê°ë‚ ë•Œë§ˆë‹¤ ê³ ë¯¼í•´ë´¤ëŠ”ë° ê²°êµ­ Recursiveë¥¼ ì‚¬ìš©í•´ì•¼ í’€ ìˆ˜ ìžˆì„ ê²ƒ ê°™ì•˜ë‹¤. 

ê²°êµ­ ì˜¤ëŠ˜ë„ ì‹¤íŒ¨í•˜ê³ â€¦ ì”

ì•Œê³ ë¦¬ì¦˜ì˜ ë„ì›€ì„ ì¢€ ë°›ì•˜ë‹¤. ã… .ã… 

```python
from typing import List

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        dislike_dic = {}
        for dislike in dislikes:
            item1 = dislike[0]
            item2 = dislike[1]
            if item1 in dislike_dic:
                dislike_dic[item1].append(item2)
            else:
                dislike_dic[item1] = [item2]

            if item2 in dislike_dic:
                dislike_dic[item2].append(item1)
            else:
                dislike_dic[item2] = [item1]

        groups = {}
        for n in range(1, n+1):
            color = groups.get(n, -1)
            if color == -1:
                groups[n] = 0
                if not self.coloring(groups, dislike_dic, n, 0):
                    return False
        return True
    
    def coloring(self, groups: dict, dislike_dic: dict, n: int, color: int):
        coloring = color ^ 1
        lst_dislike = dislike_dic.get(n, [])
        for i in lst_dislike:
            i_color = groups.get(i, -1)
            if i_color == -1:
                groups[i] = coloring
                self.coloring(groups, dislike_dic, i, coloring)
            elif i_color != coloring:
                return False
        return True
```

í•µì‹¬ì½”ë“œëŠ”

```python
self.coloring(groups, dislike_dic, i, coloring)
```

ì´ë¶€ë¶„ì´ë‹¤. 

forë¬¸ì„ ëŒë¦¬ë©´ì„œ 1ë¶€í„° nê¹Œì§€ ë„ëŠ”ë° ë‚´ê°€ ì„  coloringí•œ ë¶€ë¶„ê³¼ ì—°ê´€ëœ dislikeëŠ” ì „ë¶€ coloringì²˜ë¦¬ í•´ì¤˜ì•¼í•˜ê³  ì¼ë‹¨ ë‹¤ coloring ë˜ë©´ ë‹¤ìŒ nì¸ 2ë¥¼ ì‹œìž‘í•˜ëŠ” ê²ƒì´ë‹¤.

forë¬¸ê³¼ recursiveë¥¼ ë™ì‹œì— í™œìš©í•´ì„œ í•´ê²°í•´ì•¼ í•˜ëŠ” ë¬¸ì œì´ë‹¤.!!

copilot ì½”ë“œë¥¼ ì°¸ê³ í•´ì„œ ì§  ì½”ë“œëŠ” ì•„ëž˜ì™€ ê°™ë‹¤.

```python
class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        lst_dislikes = [[] for _ in range(0, n+1)]
        for a, b in dislikes:
            lst_dislikes[a].append(b)
            lst_dislikes[b].append(a)

        colors = [-1 for _ in range(0, n+1)]
        for n in range(1, n+1):
            if colors[n] == -1 and not self.coloring(lst_dislikes, colors, n, 0):
                return False
        return True

    def coloring(self, lst_dislikes: List[List[int]], colors:List[int], n: int, color: int):
        if colors[n] != -1:
            return colors[n] == color
        colors[n] = color
        for i in lst_dislikes[n]:
            if not self.coloring(lst_dislikes, colors, i, color ^ 1):
                return False
        return True
```

í›¨ì”¬ ê°„ë‹¨í•˜ê³  ë¹ ë¥´ë‹¤.

copilotì›ë³¸ì€ ì•„ëž˜ì™€ ê°™ë‹¤.

```python
from typing import List

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        lst_dislikes = [[] for _ in range(n)]
        for i, j in dislikes:
            lst_dislikes[i - 1].append(j - 1)
            lst_dislikes[j - 1].append(i - 1)
            
        lst_color = [0] * n
        for i in range(n):
            if lst_color[i] == 0:
                lst_color[i] = 1
                if not self.dfs(lst_dislikes, lst_color, i):
                    return False
        return True
    
    def dfs(self, lst_dislikes, lst_color, i):
        for j in lst_dislikes[i]:
            if lst_color[j] == lst_color[i]:
                return False
            if lst_color[j] == 0:
                lst_color[j] = -lst_color[i]
                if not self.dfs(lst_dislikes, lst_color, j):
                    return False
        return True
```