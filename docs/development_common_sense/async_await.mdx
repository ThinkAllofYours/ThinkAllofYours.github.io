---
slug: async_await
title: 🚀 async/await
authors: [bundabergman]
tags: [development_common_sense, async_await]
description: Node.js 환경에서 Promise와 async/await의 동작 방식, 동기/비동기 처리의 차이, 그리고 실전 예시와 함께 논블로킹의 원리를 설명합니다.
keywords: [Node.js, async, await, Promise, 비동기, 논블로킹, 이벤트 루프]
---

이 문서는 **Node.js 환경에서 비동기 처리를 위한 Promise와 async/await의 동작 방식**, 그리고 동기 방식과의 주요 차이점에 대해 설명합니다.

---

## 동기(Synchronous) 처리 방식: 블로킹

**개념:**  
코드가 작성된 순서대로 하나씩 실행되며, 특정 작업(특히 I/O)이 완료될 때까지 다음 코드의 실행이 멈춥니다(블로킹).

- **Node.js 예시:** `fs.readFileSync`, `fs.writeFileSync` 등 `Sync` 접미사가 붙은 함수들

**동작 원리:**

- 동기 함수가 호출되면, Node.js의 메인 스레드는 해당 작업이 완료될 때까지 대기합니다.
- 이 시간 동안 이벤트 루프는 멈추고, `setTimeout`, `setInterval`, 네트워크 요청 등 다른 모든 작업이 지연됩니다.

<Admonition type="caution" title="성능 저하 주의">
서버 애플리케이션과 같이 동시에 여러 요청을 처리해야 하는 환경에서는 동기 블로킹이 심각한 성능 저하의 원인이 됩니다.
</Admonition>

**예시 코드:**

```js
console.log("작업 시작");
// 이 라인에서 메인 스레드가 멈춤
const data = fs.readFileSync('large-file.txt');
console.log("파일 읽기 완료"); // 위의 작업이 끝나야 실행됨
console.log("다른 작업 시작"); // 순차적으로 실행됨
```

---

## 비동기(Asynchronous) 처리 방식: 논블로킹

**개념:**  
특정 작업(특히 I/O)을 시작시킨 후, 그 작업이 완료되기를 기다리지 않고 즉시 다음 코드를 실행합니다. 작업 완료는 나중에 콜백, Promise 등으로 처리됩니다.

- **Node.js 기반:** 이벤트 루프, 콜백 함수, Promise 객체

**동작 원리:**

- 비동기 함수(예: `fs.readFile`)가 호출되면, Node.js는 해당 작업을 백그라운드에 요청만 하고 즉시 반환합니다.
- 메인 스레드는 멈추지 않고 계속해서 다른 코드를 실행하거나 이벤트 루프를 통해 다른 이벤트를 처리합니다.
- 백그라운드 작업이 완료되면, 등록된 콜백 함수나 Promise의 후속 처리가 이벤트 큐에 추가되어 실행됩니다.

<Admonition type="tip" title="Node.js의 강점">
I/O 작업 대기 시간 동안 다른 작업을 처리할 수 있어 높은 처리량과 반응성을 가집니다.
</Admonition>

---

## Promise란?

**개념:**  
비동기 작업의 최종 완료 또는 실패 상태와 그 결과 값을 나타내는 객체입니다. 콜백 지옥(Callback Hell)을 해결하고 비동기 코드를 더 구조적으로 작성하는 데 도움을 줍니다.

**상태:**
- `pending`: 초기 상태 (완료 또는 실패 전)
- `fulfilled`: 작업이 성공적으로 완료됨
- `rejected`: 작업이 실패함

**주요 메소드:**
- `.then(onFulfilled, onRejected)`
- `.catch(onRejected)`
- `.finally(onFinally)`

---

## async/await란?

**개념:**  
Promise를 기반으로 동작하는 **문법적 설탕(Syntactic Sugar)**입니다. 비동기 코드를 마치 동기 코드처럼 더 읽기 쉽고 간결하게 작성할 수 있게 해줍니다.

### async function

- 함수 선언 시 `async` 키워드를 붙이면 해당 함수는 항상 Promise를 반환합니다.
- 함수 내에서 예외가 발생하면, 반환되는 Promise는 `Promise.reject()`로 처리됩니다.

### await 연산자

- `async` 함수 내에서만 사용 가능
- `await` 뒤에는 주로 Promise가 옴 (Promise가 아닌 값이 오면 즉시 그 값으로 처리)
- await는 뒤따르는 Promise가 처리될 때까지 현재 async 함수의 실행을 일시 중지시킵니다.
- **중요:** async 함수의 실행은 멈추지만, Node.js의 메인 스레드는 멈추지 않습니다(논블로킹). 제어권은 즉시 이벤트 루프에게 반환되어 다른 작업을 처리할 수 있습니다.

---

## 실전 예시

```js
async function processAsyncTask() {
  console.log("비동기 작업 시작");
  try {
    // readFileAsync가 Promise를 반환한다고 가정
    console.log("파일 읽기 시작 (await)...");
    // 여기서 함수의 실행은 잠시 멈추지만, 이벤트 루프는 계속 동작!
    const data = await readFileAsync('some-file.txt');
    console.log("파일 읽기 완료:", data); // await이 끝나면 실행 재개

    console.log("다른 비동기 작업 시작 (await)...");
    const result = await anotherAsyncTask(data);
    console.log("다른 비동기 작업 완료:", result);

  } catch (error) {
    console.error("오류 발생:", error);
  }
  console.log("모든 비동기 작업 완료");
}
```

### 상세 코드
```js 
// test_io_delayed.js

// 필요한 모듈 가져오기
const fs = require('fs'); // 파일 시스템 동기 함수용
const fsPromises = require('fs').promises; // 파일 시스템 비동기 함수용 (Promise 기반)
const path = require('path'); // 파일 경로 처리용

// 테스트용 파일 경로 설정 (코드가 실행되는 디렉토리에 생성됨)
const syncFilePath = path.join(__dirname, 'dummy-sync.txt');
const asyncFilePath = path.join(__dirname, 'dummy-async.txt');
// 파일 크기 (라인 수) - 여전히 크게 유지하여 실제 I/O 시간도 포함되도록 함
const FILE_SIZE_LINES = 1000000; // 백만 라인
// 비동기 작업에 추가할 인위적인 지연 시간 (ms)
const ASYNC_DELAY_MS = 350; // 350ms (200ms 이상으로 설정)

// --- 1. 동기 블로킹 예제 함수 (이전과 동일) ---
```js
// test_io_delayed.js

// 필요한 모듈 가져오기
const fs = require('fs'); // 파일 시스템 동기 함수용
const fsPromises = require('fs').promises; // 파일 시스템 비동기 함수용 (Promise 기반)
const path = require('path'); // 파일 경로 처리용

// 테스트용 파일 경로 설정 (코드가 실행되는 디렉토리에 생성됨)
const syncFilePath = path.join(__dirname, 'dummy-sync.txt');
const asyncFilePath = path.join(__dirname, 'dummy-async.txt');
// 파일 크기 (라인 수) - 여전히 크게 유지하여 실제 I/O 시간도 포함되도록 함
const FILE_SIZE_LINES = 1000000; // 백만 라인
// 비동기 작업에 추가할 인위적인 지연 시간 (ms)
const ASYNC_DELAY_MS = 350;

// --- 1. 동기 블로킹 예제 함수 (이전과 동일) ---
function runSyncBlockingExample() {
    console.log("\n--- [시작] 동기 (readFileSync) 블로킹 테스트 ---");
    try {
        let fileContent = '';
        for (let i = 0; i < FILE_SIZE_LINES; i++) {
            fileContent += `동기 테스트 파일 라인 ${i + 1}\n`;
        }
        fs.writeFileSync(syncFilePath, fileContent);
        console.log("[Sync] 테스트 파일 생성 완료.");
    } catch (err) {
        return;
    }

    let syncIntervalCount = 0;
    console.log("[Sync] 타이머 시작됨 (100ms 간격). readFileSync 실행 전.");
    const syncTimer = setInterval(() => {
        syncIntervalCount++;
        console.log(`[Sync Timer] ${syncIntervalCount * 100}ms 경과 (이벤트 루프가 활성화되어야 출력됨)`);
    }, 100);
    console.log("[Sync] >>> readFileSync 호출 시작... 이제 메인 스레드는 여기서 멈춥니다! <<<");
    try {
        const data = fs.readFileSync(syncFilePath, 'utf8');
        console.log("[Sync] readFileSync가 완료된 후에야 이 메시지가 출력되고, 타이머도 다시 동작할 수 있습니다(하지만 바로 종료할 예정).");
    } catch (err) {
    } finally {
        clearInterval(syncTimer);
        console.log("--- [종료] 동기 (readFileSync) 블로킹 테스트 ---");
    }
}


// --- 비동기 파일 읽기에 인위적인 지연을 추가하는 헬퍼 함수 ---
async function readFileWithDelay(filePath, encoding, delayMs) {
    // 1. 실제 파일 읽기 (비동기)
    const data = await fsPromises.readFile(filePath, encoding);

    // 2. 인위적인 비동기 지연 추가
    if (delayMs > 0) {
        // setTimeout을 Promise로 감싸서 await 가능하게 만듦
        await new Promise(resolve => setTimeout(resolve, delayMs));
    }
    // 3. 파일 데이터 반환
    return data;
}


// --- 2. 비동기 논블로킹 예제 함수 (수정됨) ---
// 비동기 작업을 위해 async 함수로 정의
async function runAsyncNonBlockingExample() {
    console.log("\n--- [시작] 비동기 (readFile + 인공지연) 논블로킹 테스트 ---");

    // 2-1. 테스트용 대용량 파일 '비동기적'으로 생성 (이전과 동일)
    console.log(`[Async] 테스트 파일 생성 시작 (${asyncFilePath})...`);
    try {
        let fileContent = '';
        for (let i = 0; i < FILE_SIZE_LINES; i++) {
            fileContent += `비동기 테스트 파일 라인 ${i + 1}\n`;
        }
        await fsPromises.writeFile(asyncFilePath, fileContent);
        console.log("[Async] 테스트 파일 생성 완료.");
    } catch (err) {
        console.error("[Async] 파일 생성 중 오류 발생:", err);
        return;
    }

    // 2-2. 주기적으로 메시지를 출력하는 타이머 설정 (100ms 간격)
    let asyncIntervalCount = 0;
    const asyncTimer = setInterval(() => {
        asyncIntervalCount++;
        // 중요: 이 로그는 아래 await readFileWithDelay 작업이 진행되는 '중에도' 계속 출력됩니다.
        console.log(`[Async Timer] ${asyncIntervalCount * 100}ms 경과 (이벤트 루프 활성 상태)`);
    }, 100);
    console.log("[Async] 타이머 시작됨 (100ms 간격). readFile 호출 전.");

    // 2-3. 지연이 추가된 비동기 파일 읽기 실행 (!!! 여기가 논블로킹 지점 !!!)
    console.log(`[Async] >>> await readFileWithDelay 호출 시작 (파일 읽기 + ${ASYNC_DELAY_MS}ms 지연)... 메인 스레드는 멈추지 않습니다! <<<`);
    try {
        const startTime = Date.now(); // 전체 작업 시작 시간 기록

        // 수정된 부분: 직접 readFile 대신 readFileWithDelay 함수 호출
        const data = await readFileWithDelay(asyncFilePath, 'utf8', ASYNC_DELAY_MS);

        const endTime = Date.now(); // 전체 작업 종료 시간 기록
        // 이 로그는 파일 읽기와 추가 지연이 '모두 완료된 시점'에 출력됩니다.
        console.log(`[Async] >>> await readFileWithDelay 완료! <<< ${Buffer.byteLength(data)} 바이트 읽음.`);
        console.log(`[Async] 전체 작업(읽기+지연) 소요 시간: ${endTime - startTime}ms`);
        console.log(`[Async] 파일 읽기 + 지연 작업이 진행되는 동안 타이머(${asyncIntervalCount}번)가 계속 동작했음을 확인할 수 있습니다.`);

    } catch (err) {
        console.error("[Async] 작업 중 오류 발생:", err);
    } finally {
        // 2-4. 타이머 정리
        clearInterval(asyncTimer);
        console.log("[Async] 타이머 종료됨.");
        console.log("--- [종료] 비동기 (readFile + 인공지연) 논블로킹 테스트 ---");
    }
}

// --- 3. 예제 실행 및 파일 정리 (이전과 동일) ---
async function runTests() {
    // 동기 예제 실행
    runSyncBlockingExample();

    // 비동기 예제 실행 전 잠시 대기 (콘솔 출력 구분을 위해)
    console.log("\n잠시 후 비동기 테스트를 시작합니다...");
    await new Promise(resolve => setTimeout(resolve, 1500)); // 1.5초 대기

    // 비동기 예제 실행
    await runAsyncNonBlockingExample();

    // 테스트 완료 후 생성된 임시 파일 삭제 (정리)
    console.log("\n--- 테스트 파일 정리 시작 ---");
    try {
        if (fs.existsSync(syncFilePath)) {
            fs.unlinkSync(syncFilePath);
            console.log(`[정리] ${syncFilePath} 삭제 완료.`);
        }
        try {
            await fsPromises.stat(asyncFilePath);
            await fsPromises.unlink(asyncFilePath);
            console.log(`[정리] ${asyncFilePath} 삭제 완료.`);
        } catch (statErr) {
            if (statErr.code !== 'ENOENT') {
               console.error(`[정리] ${asyncFilePath} 상태 확인/삭제 중 오류:`, statErr);
            } else {
               console.log(`[정리] ${asyncFilePath} 파일이 이미 없거나 생성되지 않았습니다.`);
            }
        }
    } catch (err) {
        console.error("[정리] 파일 삭제 중 오류 발생:", err);
    }
    console.log("--- 모든 테스트 및 정리 완료 ---");
}

// 전체 테스트 실행
runTests();
```


---

## 시연 코드 요약

- `readFileSync`(동기)가 실행되는 동안 `setInterval` 타이머가 완전히 멈추는 블로킹 현상을 확인할 수 있습니다.
- 반면, `await fsPromises.readFile`(비동기)가 실행되는 동안에는(심지어 인위적인 지연을 추가해도) `setInterval` 타이머가 계속 실행됩니다.  
  → await가 메인 스레드를 차단하지 않고 이벤트 루프가 다른 작업을 계속 처리할 수 있게 함을 증명합니다.

---

## 결론

async/await는 **비동기 코드를 동기 코드처럼 보이게 하여 가독성을 높이지만**, 내부적으로는 Promise와 이벤트 루프를 기반으로 한 논블로킹 방식으로 동작하여 **Node.js의 높은 성능과 반응성을 유지하는 핵심적인 기능**입니다.
